<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/ts-course/images/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/ts-course/images/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/ts-course/images/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="16x16" href="/ts-course/images/favicon-16x16.png"/><link rel="icon" type="image/x-icon" href="/ts-course/images/favicon.ico"/><title>Variables and Values – TypeScript Essentials</title><meta name="description" content="Variable and Values"/><meta name="keywords" content="TypeScript,Learning"/><meta name="og:description" content="Variable and Values"/><meta name="og:title" content="Variables and Values – TypeScript Essentials"/><meta name="og:image" content="/ts-course/images/social-share-cover.jpg"/><meta name="twitter:card" content="summary_large_image"/><meta name="next-head-count" content="14"/><link data-next-font="size-adjust" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/ts-course/_next/static/css/1ccb4aa71109111b.css" as="style"/><link rel="stylesheet" href="/ts-course/_next/static/css/1ccb4aa71109111b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/ts-course/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/ts-course/_next/static/chunks/webpack-5d9a844457aaaed5.js" defer=""></script><script src="/ts-course/_next/static/chunks/framework-305cb810cde7afac.js" defer=""></script><script src="/ts-course/_next/static/chunks/main-c07c534f0a97340a.js" defer=""></script><script src="/ts-course/_next/static/chunks/pages/_app-b8cecf7a9cc59578.js" defer=""></script><script src="/ts-course/_next/static/chunks/pages/lessons/%5Bsection%5D/%5Bslug%5D-743513d9d19eb3a4.js" defer=""></script><script src="/ts-course/_next/static/4hRIBD8wXgMp_ivLKlngK/_buildManifest.js" defer=""></script><script src="/ts-course/_next/static/4hRIBD8wXgMp_ivLKlngK/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="remix-app"><header class="navbar"><h1 class="navbar-brand"><a href="/ts-course">TypeScript Essentials</a></h1><div class="navbar-info"><a href="https://amanjacademy.com/javascript/" class="cta-btn">Watch on Amanj Academy</a></div></header><div class="content-container"><div class="main"><div class="lesson-container"><div class="lesson"><div class="lesson-content"><h1 id="variables-and-values">Variables and Values</h1>
<h2 id="variable-declarations--inference">Variable Declarations &amp; Inference</h2>
<p>In JavaScript we declare variables all the time with <strong>let</strong> and <strong>const</strong> like this:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> age = <span class="hljs-number">6</span>
</code></pre>
<p>As we can see, TypeScript is able to <strong>infer</strong> that <strong>age</strong> is a number, based on the fact that we’re initializing it with a value as we are declaring it.</p>
<br>

<p>If we try to give age a value that is incompatible with number, we get an error</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> age = <span class="hljs-number">6</span>
age = <span class="hljs-string">&quot;not a number&quot;</span>
</code></pre>
<p><strong>In TypeScript, variables are “born” with their types.</strong> Although there are ways of making them more specific in certain branches of code, there’s no (safe) way of changing age’s type from number to string.</p>
<br>

<p>Let’s try the same thing with const:</p>
<pre><code>const age = 6
</code></pre>
<p>Notice that the type of this variable is not <strong>number</strong>, it’s <strong>6</strong>. <strong>TS is able to make a more specific assumption here</strong>, because:</p>
<ul>
<li>const variable declarations cannot be reassigned</li>
<li>the initial value assigned to age is a number, which is an <strong>immutable value type</strong></li>
</ul>
<p>Therefore, <strong>age</strong> will always be <strong>6</strong> in this program.</p>
<h2 id="literal-types">Literal Types</h2>
<p>The type <strong>6</strong> is called a <strong>literal type</strong>. If our let declaration is a variable that can hold any number, the const declaration is one that can hold only 6 — a specific number.</p>
<h2 id="implicit-any-and-type-annotations">Implicit any and type annotations</h2>
<p>Sometimes, we need to declare a variable before it gets initialized, like <strong>endTime</strong> below:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// between 500 and 1000</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">RANDOM_WAIT_TIME</span> =
  <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">500</span>) + <span class="hljs-number">500</span>
 
<span class="hljs-keyword">let</span> startTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()
<span class="hljs-keyword">let</span> endTime
      
<span class="hljs-keyword">let</span> <span class="hljs-attr">endTime</span>: any
 
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  endTime = <span class="hljs-number">0</span>
  endTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()
}, <span class="hljs-variable constant_">RANDOM_WAIT_TIME</span>)
</code></pre>
<p><strong>endTime</strong> is “born” without a type, so it ends up being an implicit <strong>any</strong>.</p>
<p>TypeScript doesn’t have enough information around the declaration site to infer what endTime should be, so it gets the <strong>most flexible type: any</strong>.</p>
<p>Think of any as “the normal way JS variables work”, in that you could assign endTime to a number, then later a function, then a string.</p>
<p>If we wanted more safety here, we could add a <strong>type annotation</strong>:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// between 500 and 1000</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">RANDOM_WAIT_TIME</span> =
  <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">500</span>) + <span class="hljs-number">500</span>
 
<span class="hljs-keyword">let</span> startTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()
<span class="hljs-keyword">let</span> <span class="hljs-attr">endTime</span>: <span class="hljs-title class_">Date</span>
      
<span class="hljs-keyword">let</span> <span class="hljs-attr">endTime</span>: <span class="hljs-title class_">Date</span>
 
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  endTime = <span class="hljs-number">0</span>
<span class="hljs-title class_">Type</span> <span class="hljs-string">&#x27;number&#x27;</span> is not assignable to type <span class="hljs-string">&#x27;Date&#x27;</span>.
  endTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()
}, <span class="hljs-variable constant_">RANDOM_WAIT_TIME</span>)
</code></pre>
<p>Now, TypeScript will correctly alert us when we try to flip flop between the number <strong>0</strong> and a <strong>Date</strong>.</p>
<h2 id="function-arguments-and-return-values">Function arguments and return values</h2>
<p>The <strong>: foo</strong> syntax we’ve just seen for variable type annotations can also be used to describe function arguments and return values. In this example it’s not clear, even from the implementation of the function, whether <strong>add</strong> should accept numbers or strings.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) {
  <span class="hljs-keyword">return</span> a + b <span class="hljs-comment">// strings? numbers? a mix?</span>
}
</code></pre>
<p>Here’s what your in-editor tooltip would look like if you were using this function:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;4&quot;</span>)
<span class="hljs-comment">//function add(a: any, b: any): any</span>
result
</code></pre>
<p>Without type annotations, “anything goes” for the arguments passed into <strong>add</strong>. Why is this a problem?</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;4&quot;</span>)
<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(result)
</code></pre>
<p>If you’ve ever created a Promise using the promise constructor, you may see that we are using a string where we should use a two-argument function. This is the kind of thing we’d hope that TypeScript could catch for us.</p>
<br>

<p>Without type annotations, “anything goes” for the arguments passed into add. Why is this a problem?</p>
<p>Let’s add some type annotations to our function’s arguments:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: number, b: number</span>) {
  <span class="hljs-keyword">return</span> a + b
}
<span class="hljs-keyword">const</span> result = <span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;4&quot;</span>)
</code></pre>
<p>Great, now we can enforce that only values of type <strong>number</strong> are passed into the function, and TS can now determine the return type automatically:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: number, b: number</span>) {
  <span class="hljs-keyword">return</span> a + b
}
<span class="hljs-keyword">const</span> result = <span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
</code></pre>
<p>If we wanted to specifically state a return type, we could do so using the :foo syntax in one more place</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: number, b: number</span>): number {}
</code></pre>
<p>This is a great way for code authors to state their intentions up-front. TypeScript will make sure that we live up to this intention, and errors will be surfaced at the location of the function declaration instead of where we use the value returned by the function.</p>
</div><div class="lesson-links"><a href="/ts-course/lessons/Setup/hello-typescript" class="prev">← Previous</a></div></div><div class="details-bg"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="154" height="154" viewBox="0 0 154 154"><defs><clipPath id="clip-path"><rect id="Rectangle_2238" data-name="Rectangle 2238" width="154" height="154" transform="translate(9467 350)" fill="#fff" stroke="#707070" stroke-width="1"></rect></clipPath><clipPath id="clip-corner-image-active"><rect width="154" height="154"></rect></clipPath></defs><g id="corner-image-active" clip-path="url(#clip-corner-image-active)"><g id="Corner-image-active-2" data-name="Corner-image-active" transform="translate(-9467 -350)" clip-path="url(#clip-path)"><path id="Subtraction_34" data-name="Subtraction 34" d="M-3857.365,1740.766h0l-7.07-7.07,12.89-12.89v14.142l-5.818,5.818Zm-14.142-14.142h0l-7.071-7.07,27.033-27.033v14.143l-19.96,19.96Zm-14.143-14.143h0l-7.07-7.069,41.175-41.175v14.142Zm-14.142-14.142h0l-7.07-7.069,55.317-55.317v14.142Zm-14.142-14.142h0l-7.07-7.069,69.459-69.459v14.142Zm-14.142-14.142h0l-7.07-7.069,76.739-76.739h6.862v7.28Zm-14.143-14.143h0l-7.07-7.069,62.6-62.6h14.142Zm-14.142-14.142h0l-7.07-7.069,48.454-48.454h14.142Zm-14.142-14.142h0l-7.07-7.069,34.312-34.312h14.142Zm-14.142-14.142h0l-7.07-7.069,20.17-20.17h14.142Zm-14.142-14.142h0l-7.071-7.071,6.027-6.027h14.144l-13.1,13.1Zm367.24-56.114v-.909l.455.455-.453.453Z" transform="translate(13472.546 -1236.766)" fill="var(--corner-fill)"></path></g></g></svg></div></div></div></div><footer class="footer"><ul class="socials"><li class="social"><a href="https://twitter.com/pjsofts"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="40" height="32" viewBox="0 0 40 32"><defs><clipPath id="clip-twitter-social"><rect width="40" height="32"></rect></clipPath></defs><g id="twitter-social" clip-path="url(#clip-twitter-social)"><g id="Group_269" data-name="Group 269" transform="translate(-230.23 -1140.849)"><path id="Path_419" data-name="Path 419" d="M266.12,1148.861v1.035a23.092,23.092,0,0,1-1.507,8.1,24.08,24.08,0,0,1-4.475,7.381,22.175,22.175,0,0,1-7.306,5.4,24.129,24.129,0,0,1-10,2.07,23.7,23.7,0,0,1-6.667-.945,22.83,22.83,0,0,1-5.936-2.655q.959.091,1.963.09a16.518,16.518,0,0,0,5.434-.9,17.111,17.111,0,0,0,4.749-2.52,8.275,8.275,0,0,1-4.749-1.643,7.8,7.8,0,0,1-2.877-3.983,8.268,8.268,0,0,0,1.507.135,8.58,8.58,0,0,0,2.146-.27,8.16,8.16,0,0,1-5.685-4.344,8.326,8.326,0,0,1-.89-3.578v-.135a7.775,7.775,0,0,0,3.744,1.035,8.183,8.183,0,0,1-2.671-2.9,7.817,7.817,0,0,1-.982-3.848,7.948,7.948,0,0,1,1.1-4.05,23.53,23.53,0,0,0,16.895,8.46,9.221,9.221,0,0,1-.183-1.845,7.787,7.787,0,0,1,1.1-4.05,8.216,8.216,0,0,1,2.991-2.948,7.991,7.991,0,0,1,4.087-1.1,8.184,8.184,0,0,1,5.982,2.566,16.087,16.087,0,0,0,5.205-1.98,7.784,7.784,0,0,1-1.393,2.588,8.4,8.4,0,0,1-2.215,1.913,16.856,16.856,0,0,0,4.749-1.305A17.032,17.032,0,0,1,266.12,1148.861Z" fill="var(--footer-icons)"></path></g></g></svg></a></li><li class="social"><a href="https://github.com/pjsofts"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-github-social"><rect width="32" height="32"></rect></clipPath></defs><g id="github-social" clip-path="url(#clip-github-social)"><g id="Group_272" data-name="Group 272" transform="translate(13522.5 -6994)"><path id="Subtraction_33" data-name="Subtraction 33" d="M-24967.5,8041a15.9,15.9,0,0,1-11.312-4.688A15.893,15.893,0,0,1-24983.5,8025a15.893,15.893,0,0,1,4.689-11.315A15.894,15.894,0,0,1-24967.5,8009a15.894,15.894,0,0,1,11.313,4.686A15.893,15.893,0,0,1-24951.5,8025a15.893,15.893,0,0,1-4.689,11.313A15.9,15.9,0,0,1-24967.5,8041Zm-3.781-4.571h0v3.918h7.895v-6.665a1.836,1.836,0,0,0-1.2-1.718c5.1-.617,7.467-2.975,7.467-7.424a7.176,7.176,0,0,0-1.637-4.728,6.74,6.74,0,0,0,.275-1.812,4.34,4.34,0,0,0-.52-2.452.574.574,0,0,0-.359-.1c-1.061,0-3.465,1.411-3.936,1.694a16.644,16.644,0,0,0-4.2-.489,16.379,16.379,0,0,0-3.969.445c-.846-.5-2.91-1.649-3.859-1.649a.566.566,0,0,0-.354.095,4.3,4.3,0,0,0-.521,2.452,6.7,6.7,0,0,0,.244,1.718,7.346,7.346,0,0,0-1.6,4.822,7.263,7.263,0,0,0,1.533,4.985c1.193,1.359,3.115,2.165,5.871,2.464a1.826,1.826,0,0,0-1.129,1.693v.5h0l-.006,0a7.121,7.121,0,0,1-2.033.363,2.608,2.608,0,0,1-.965-.158,4.438,4.438,0,0,1-1.836-1.881,2.361,2.361,0,0,0-1.248-1.091,3.472,3.472,0,0,0-1.217-.3.584.584,0,0,0-.545.224.282.282,0,0,0,.027.367,1.875,1.875,0,0,0,.447.307,4.732,4.732,0,0,1,.561.355,10.726,10.726,0,0,1,1.682,2.755c.043.092.078.163.105.217a3.876,3.876,0,0,0,2.42,1.185,6.036,6.036,0,0,0,.607.025c.875,0,1.988-.124,2-.125Z" transform="translate(11461 -1015)" fill="var(--footer-icons)"></path><g id="Ellipse_670" data-name="Ellipse 670" transform="translate(-13522.5 6994)" fill="none" stroke="var(--footer-icons)" stroke-width="1"><circle cx="16" cy="16" r="16" stroke="none"></circle><circle cx="16" cy="16" r="15.5" fill="none"></circle></g></g></g></svg></a></li><li class="social"><a href="https://linkedin.com/in//pouria-jahandideh-879040157/"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-linkedin-social"><rect width="32" height="32"></rect></clipPath></defs><g id="linkedin-social" clip-path="url(#clip-linkedin-social)"><g id="Group_270" data-name="Group 270" transform="translate(-86.349 -633.073)"><path id="Path_375" data-name="Path 375" d="M115.789,633.073a2.324,2.324,0,0,1,1.682.676,2.194,2.194,0,0,1,.695,1.627V662.8a2.131,2.131,0,0,1-.695,1.609,2.314,2.314,0,0,1-1.646.659H88.69a2.307,2.307,0,0,1-1.646-.659,2.128,2.128,0,0,1-.695-1.609V635.376a2.19,2.19,0,0,1,.695-1.627,2.322,2.322,0,0,1,1.682-.676h27.063Zm-20.224,9.672a2.561,2.561,0,0,0,0-3.584,2.658,2.658,0,0,0-1.938-.712,2.724,2.724,0,0,0-1.957.712,2.371,2.371,0,0,0-.75,1.792,2.4,2.4,0,0,0,.731,1.792,2.605,2.605,0,0,0,1.9.713h.037A2.7,2.7,0,0,0,95.565,642.745ZM96,645.434H91.213V659.88H96Zm17.3,6.144a7.007,7.007,0,0,0-1.573-4.9,5.68,5.68,0,0,0-6.839-.769,5.663,5.663,0,0,0-1.426,1.573v-2.048H98.674q.036.841,0,7.717v6.728h4.791V651.8a3.592,3.592,0,0,1,.146-1.17,2.913,2.913,0,0,1,.878-1.206,2.429,2.429,0,0,1,1.609-.549,2.108,2.108,0,0,1,1.865.914,4.265,4.265,0,0,1,.549,2.341v7.752H113.3Z" fill="var(--footer-icons)"></path></g></g></svg></a></li><li class="social"><div class="terms"><p>Content Licensed Under CC-BY-NC-4.0</p><p>Code Samples and Excercises Licensed Under Apache 2.0</p><p>Site Designed by<!-- --> <a href="https://www.alexdanielson.com/">Alex Danielson</a></p></div></li></ul></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"attributes":{"title":"Variables and Values","description":"Variable and Values"},"html":"\u003ch1 id=\"variables-and-values\"\u003eVariables and Values\u003c/h1\u003e\n\u003ch2 id=\"variable-declarations--inference\"\u003eVariable Declarations \u0026amp; Inference\u003c/h2\u003e\n\u003cp\u003eIn JavaScript we declare variables all the time with \u003cstrong\u003elet\u003c/strong\u003e and \u003cstrong\u003econst\u003c/strong\u003e like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e age = \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs we can see, TypeScript is able to \u003cstrong\u003einfer\u003c/strong\u003e that \u003cstrong\u003eage\u003c/strong\u003e is a number, based on the fact that we’re initializing it with a value as we are declaring it.\u003c/p\u003e\n\u003cbr\u003e\n\n\u003cp\u003eIf we try to give age a value that is incompatible with number, we get an error\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e age = \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e\nage = \u003cspan class=\"hljs-string\"\u003e\u0026quot;not a number\u0026quot;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eIn TypeScript, variables are “born” with their types.\u003c/strong\u003e Although there are ways of making them more specific in certain branches of code, there’s no (safe) way of changing age’s type from number to string.\u003c/p\u003e\n\u003cbr\u003e\n\n\u003cp\u003eLet’s try the same thing with const:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst age = 6\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice that the type of this variable is not \u003cstrong\u003enumber\u003c/strong\u003e, it’s \u003cstrong\u003e6\u003c/strong\u003e. \u003cstrong\u003eTS is able to make a more specific assumption here\u003c/strong\u003e, because:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003econst variable declarations cannot be reassigned\u003c/li\u003e\n\u003cli\u003ethe initial value assigned to age is a number, which is an \u003cstrong\u003eimmutable value type\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTherefore, \u003cstrong\u003eage\u003c/strong\u003e will always be \u003cstrong\u003e6\u003c/strong\u003e in this program.\u003c/p\u003e\n\u003ch2 id=\"literal-types\"\u003eLiteral Types\u003c/h2\u003e\n\u003cp\u003eThe type \u003cstrong\u003e6\u003c/strong\u003e is called a \u003cstrong\u003eliteral type\u003c/strong\u003e. If our let declaration is a variable that can hold any number, the const declaration is one that can hold only 6 — a specific number.\u003c/p\u003e\n\u003ch2 id=\"implicit-any-and-type-annotations\"\u003eImplicit any and type annotations\u003c/h2\u003e\n\u003cp\u003eSometimes, we need to declare a variable before it gets initialized, like \u003cstrong\u003eendTime\u003c/strong\u003e below:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// between 500 and 1000\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eRANDOM_WAIT_TIME\u003c/span\u003e =\n  \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eround\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandom\u003c/span\u003e() * \u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e) + \u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e\n \n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e startTime = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDate\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e endTime\n      \n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eendTime\u003c/span\u003e: any\n \n\u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n  endTime = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n  endTime = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDate\u003c/span\u003e()\n}, \u003cspan class=\"hljs-variable constant_\"\u003eRANDOM_WAIT_TIME\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eendTime\u003c/strong\u003e is “born” without a type, so it ends up being an implicit \u003cstrong\u003eany\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eTypeScript doesn’t have enough information around the declaration site to infer what endTime should be, so it gets the \u003cstrong\u003emost flexible type: any\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eThink of any as “the normal way JS variables work”, in that you could assign endTime to a number, then later a function, then a string.\u003c/p\u003e\n\u003cp\u003eIf we wanted more safety here, we could add a \u003cstrong\u003etype annotation\u003c/strong\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// between 500 and 1000\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eRANDOM_WAIT_TIME\u003c/span\u003e =\n  \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eround\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandom\u003c/span\u003e() * \u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e) + \u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e\n \n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e startTime = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDate\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eendTime\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDate\u003c/span\u003e\n      \n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eendTime\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDate\u003c/span\u003e\n \n\u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n  endTime = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eType\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;number\u0026#x27;\u003c/span\u003e is not assignable to type \u003cspan class=\"hljs-string\"\u003e\u0026#x27;Date\u0026#x27;\u003c/span\u003e.\n  endTime = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDate\u003c/span\u003e()\n}, \u003cspan class=\"hljs-variable constant_\"\u003eRANDOM_WAIT_TIME\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, TypeScript will correctly alert us when we try to flip flop between the number \u003cstrong\u003e0\u003c/strong\u003e and a \u003cstrong\u003eDate\u003c/strong\u003e.\u003c/p\u003e\n\u003ch2 id=\"function-arguments-and-return-values\"\u003eFunction arguments and return values\u003c/h2\u003e\n\u003cp\u003eThe \u003cstrong\u003e: foo\u003c/strong\u003e syntax we’ve just seen for variable type annotations can also be used to describe function arguments and return values. In this example it’s not clear, even from the implementation of the function, whether \u003cstrong\u003eadd\u003c/strong\u003e should accept numbers or strings.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ea, b\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e a + b \u003cspan class=\"hljs-comment\"\u003e// strings? numbers? a mix?\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere’s what your in-editor tooltip would look like if you were using this function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = \u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;4\u0026quot;\u003c/span\u003e)\n\u003cspan class=\"hljs-comment\"\u003e//function add(a: any, b: any): any\u003c/span\u003e\nresult\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWithout type annotations, “anything goes” for the arguments passed into \u003cstrong\u003eadd\u003c/strong\u003e. Why is this a problem?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = \u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;4\u0026quot;\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e p = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e(result)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you’ve ever created a Promise using the promise constructor, you may see that we are using a string where we should use a two-argument function. This is the kind of thing we’d hope that TypeScript could catch for us.\u003c/p\u003e\n\u003cbr\u003e\n\n\u003cp\u003eWithout type annotations, “anything goes” for the arguments passed into add. Why is this a problem?\u003c/p\u003e\n\u003cp\u003eLet’s add some type annotations to our function’s arguments:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ea: number, b: number\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e a + b\n}\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = \u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;4\u0026quot;\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGreat, now we can enforce that only values of type \u003cstrong\u003enumber\u003c/strong\u003e are passed into the function, and TS can now determine the return type automatically:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ea: number, b: number\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e a + b\n}\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = \u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf we wanted to specifically state a return type, we could do so using the :foo syntax in one more place\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ea: number, b: number\u003c/span\u003e): number {}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is a great way for code authors to state their intentions up-front. TypeScript will make sure that we live up to this intention, and errors will be surfaced at the location of the function declaration instead of where we use the value returned by the function.\u003c/p\u003e\n","markdown":"\n# Variables and Values\n\n## Variable Declarations \u0026 Inference\n\nIn JavaScript we declare variables all the time with **let** and **const** like this:\n```js\nlet age = 6\n```\n\n\nAs we can see, TypeScript is able to **infer** that **age** is a number, based on the fact that we’re initializing it with a value as we are declaring it.\n\n\u003cbr\u003e\n\nIf we try to give age a value that is incompatible with number, we get an error\n\n```js\nlet age = 6\nage = \"not a number\"\n```\n\n\n**In TypeScript, variables are “born” with their types.** Although there are ways of making them more specific in certain branches of code, there’s no (safe) way of changing age’s type from number to string.\n\n\u003cbr\u003e\n\nLet’s try the same thing with const:\n\n```\nconst age = 6\n```\n\n\nNotice that the type of this variable is not **number**, it’s **6**. **TS is able to make a more specific assumption here**, because:\n\n+ const variable declarations cannot be reassigned\n+ the initial value assigned to age is a number, which is an **immutable value type**\n\nTherefore, **age** will always be **6** in this program.\n\n\n## Literal Types\nThe type **6** is called a **literal type**. If our let declaration is a variable that can hold any number, the const declaration is one that can hold only 6 — a specific number.\n\n\n## Implicit any and type annotations\n\nSometimes, we need to declare a variable before it gets initialized, like **endTime** below:\n\n```js\n// between 500 and 1000\nconst RANDOM_WAIT_TIME =\n  Math.round(Math.random() * 500) + 500\n \nlet startTime = new Date()\nlet endTime\n      \nlet endTime: any\n \nsetTimeout(() =\u003e {\n  endTime = 0\n  endTime = new Date()\n}, RANDOM_WAIT_TIME)\n\n```\n\n\n\n**endTime** is “born” without a type, so it ends up being an implicit **any**.\n\nTypeScript doesn’t have enough information around the declaration site to infer what endTime should be, so it gets the **most flexible type: any**.\n\nThink of any as “the normal way JS variables work”, in that you could assign endTime to a number, then later a function, then a string.\n\nIf we wanted more safety here, we could add a **type annotation**:\n```js\n// between 500 and 1000\nconst RANDOM_WAIT_TIME =\n  Math.round(Math.random() * 500) + 500\n \nlet startTime = new Date()\nlet endTime: Date\n      \nlet endTime: Date\n \nsetTimeout(() =\u003e {\n  endTime = 0\nType 'number' is not assignable to type 'Date'.\n  endTime = new Date()\n}, RANDOM_WAIT_TIME)\n```\n\nNow, TypeScript will correctly alert us when we try to flip flop between the number **0** and a **Date**.\n\n\n\n## Function arguments and return values\nThe **: foo** syntax we’ve just seen for variable type annotations can also be used to describe function arguments and return values. In this example it’s not clear, even from the implementation of the function, whether **add** should accept numbers or strings.\n\n```js\nfunction add(a, b) {\n  return a + b // strings? numbers? a mix?\n}\n```\n\n\nHere’s what your in-editor tooltip would look like if you were using this function:\n\n```js\nconst result = add(3, \"4\")\n//function add(a: any, b: any): any\nresult\n```\n\nWithout type annotations, “anything goes” for the arguments passed into **add**. Why is this a problem?\n\n```js\nconst result = add(3, \"4\")\nconst p = new Promise(result)\n```\n\n\nIf you’ve ever created a Promise using the promise constructor, you may see that we are using a string where we should use a two-argument function. This is the kind of thing we’d hope that TypeScript could catch for us.\n\n\u003cbr\u003e\n\nWithout type annotations, “anything goes” for the arguments passed into add. Why is this a problem?\n\nLet’s add some type annotations to our function’s arguments:\n\n\n```js\nfunction add(a: number, b: number) {\n  return a + b\n}\nconst result = add(3, \"4\")\n```\n\n\nGreat, now we can enforce that only values of type **number** are passed into the function, and TS can now determine the return type automatically:\n\n```js\nfunction add(a: number, b: number) {\n  return a + b\n}\nconst result = add(3, 4)\n```\n\nIf we wanted to specifically state a return type, we could do so using the :foo syntax in one more place\n```js\nfunction add(a: number, b: number): number {}\n```\n\nThis is a great way for code authors to state their intentions up-front. TypeScript will make sure that we live up to this intention, and errors will be surfaced at the location of the function declaration instead of where we use the value returned by the function.","slug":"Variables-Values","title":"Variables and Values","section":"TypeScript Language","icon":"file-code","filePath":"/home/runner/work/ts-course/ts-course/lessons/03-TypeScript-Language/A-Variables-Values.md","nextSlug":null,"prevSlug":"/ts-course/lessons/Setup/hello-typescript"}},"__N_SSG":true},"page":"/lessons/[section]/[slug]","query":{"section":"TypeScript-Language","slug":"Variables-Values"},"buildId":"4hRIBD8wXgMp_ivLKlngK","assetPrefix":"/ts-course","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>