{"pageProps":{"post":{"attributes":{"title":"Variables and Values","description":"Variable and Values"},"html":"<h1 id=\"variables-and-values\">Variables and Values</h1>\n<h2 id=\"variable-declarations--inference\">Variable Declarations &amp; Inference</h2>\n<p>In JavaScript we declare variables all the time with <strong>let</strong> and <strong>const</strong> like this:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> age = <span class=\"hljs-number\">6</span>\n</code></pre>\n<p>As we can see, TypeScript is able to <strong>infer</strong> that <strong>age</strong> is a number, based on the fact that we’re initializing it with a value as we are declaring it.</p>\n<br>\n\n<p>If we try to give age a value that is incompatible with number, we get an error</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> age = <span class=\"hljs-number\">6</span>\nage = <span class=\"hljs-string\">&quot;not a number&quot;</span>\n</code></pre>\n<p><strong>In TypeScript, variables are “born” with their types.</strong> Although there are ways of making them more specific in certain branches of code, there’s no (safe) way of changing age’s type from number to string.</p>\n<br>\n\n<p>Let’s try the same thing with const:</p>\n<pre><code>const age = 6\n</code></pre>\n<p>Notice that the type of this variable is not <strong>number</strong>, it’s <strong>6</strong>. <strong>TS is able to make a more specific assumption here</strong>, because:</p>\n<ul>\n<li>const variable declarations cannot be reassigned</li>\n<li>the initial value assigned to age is a number, which is an <strong>immutable value type</strong></li>\n</ul>\n<p>Therefore, <strong>age</strong> will always be <strong>6</strong> in this program.</p>\n<h2 id=\"literal-types\">Literal Types</h2>\n<p>The type <strong>6</strong> is called a <strong>literal type</strong>. If our let declaration is a variable that can hold any number, the const declaration is one that can hold only 6 — a specific number.</p>\n<h2 id=\"implicit-any-and-type-annotations\">Implicit any and type annotations</h2>\n<p>Sometimes, we need to declare a variable before it gets initialized, like <strong>endTime</strong> below:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// between 500 and 1000</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">RANDOM_WAIT_TIME</span> =\n  <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">round</span>(<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>() * <span class=\"hljs-number\">500</span>) + <span class=\"hljs-number\">500</span>\n \n<span class=\"hljs-keyword\">let</span> startTime = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>()\n<span class=\"hljs-keyword\">let</span> endTime\n      \n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">endTime</span>: any\n \n<span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> {\n  endTime = <span class=\"hljs-number\">0</span>\n  endTime = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>()\n}, <span class=\"hljs-variable constant_\">RANDOM_WAIT_TIME</span>)\n</code></pre>\n<p><strong>endTime</strong> is “born” without a type, so it ends up being an implicit <strong>any</strong>.</p>\n<p>TypeScript doesn’t have enough information around the declaration site to infer what endTime should be, so it gets the <strong>most flexible type: any</strong>.</p>\n<p>Think of any as “the normal way JS variables work”, in that you could assign endTime to a number, then later a function, then a string.</p>\n<p>If we wanted more safety here, we could add a <strong>type annotation</strong>:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// between 500 and 1000</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">RANDOM_WAIT_TIME</span> =\n  <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">round</span>(<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>() * <span class=\"hljs-number\">500</span>) + <span class=\"hljs-number\">500</span>\n \n<span class=\"hljs-keyword\">let</span> startTime = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>()\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">endTime</span>: <span class=\"hljs-title class_\">Date</span>\n      \n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">endTime</span>: <span class=\"hljs-title class_\">Date</span>\n \n<span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> {\n  endTime = <span class=\"hljs-number\">0</span>\n<span class=\"hljs-title class_\">Type</span> <span class=\"hljs-string\">&#x27;number&#x27;</span> is not assignable to type <span class=\"hljs-string\">&#x27;Date&#x27;</span>.\n  endTime = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>()\n}, <span class=\"hljs-variable constant_\">RANDOM_WAIT_TIME</span>)\n</code></pre>\n<p>Now, TypeScript will correctly alert us when we try to flip flop between the number <strong>0</strong> and a <strong>Date</strong>.</p>\n<h2 id=\"function-arguments-and-return-values\">Function arguments and return values</h2>\n<p>The <strong>: foo</strong> syntax we’ve just seen for variable type annotations can also be used to describe function arguments and return values. In this example it’s not clear, even from the implementation of the function, whether <strong>add</strong> should accept numbers or strings.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">a, b</span>) {\n  <span class=\"hljs-keyword\">return</span> a + b <span class=\"hljs-comment\">// strings? numbers? a mix?</span>\n}\n</code></pre>\n<p>Here’s what your in-editor tooltip would look like if you were using this function:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&quot;4&quot;</span>)\n<span class=\"hljs-comment\">//function add(a: any, b: any): any</span>\nresult\n</code></pre>\n<p>Without type annotations, “anything goes” for the arguments passed into <strong>add</strong>. Why is this a problem?</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&quot;4&quot;</span>)\n<span class=\"hljs-keyword\">const</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(result)\n</code></pre>\n<p>If you’ve ever created a Promise using the promise constructor, you may see that we are using a string where we should use a two-argument function. This is the kind of thing we’d hope that TypeScript could catch for us.</p>\n<br>\n\n<p>Without type annotations, “anything goes” for the arguments passed into add. Why is this a problem?</p>\n<p>Let’s add some type annotations to our function’s arguments:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">a: number, b: number</span>) {\n  <span class=\"hljs-keyword\">return</span> a + b\n}\n<span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&quot;4&quot;</span>)\n</code></pre>\n<p>Great, now we can enforce that only values of type <strong>number</strong> are passed into the function, and TS can now determine the return type automatically:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">a: number, b: number</span>) {\n  <span class=\"hljs-keyword\">return</span> a + b\n}\n<span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>)\n</code></pre>\n<p>If we wanted to specifically state a return type, we could do so using the :foo syntax in one more place</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">a: number, b: number</span>): number {}\n</code></pre>\n<p>This is a great way for code authors to state their intentions up-front. TypeScript will make sure that we live up to this intention, and errors will be surfaced at the location of the function declaration instead of where we use the value returned by the function.</p>\n","markdown":"\n# Variables and Values\n\n## Variable Declarations & Inference\n\nIn JavaScript we declare variables all the time with **let** and **const** like this:\n```js\nlet age = 6\n```\n\n\nAs we can see, TypeScript is able to **infer** that **age** is a number, based on the fact that we’re initializing it with a value as we are declaring it.\n\n<br>\n\nIf we try to give age a value that is incompatible with number, we get an error\n\n```js\nlet age = 6\nage = \"not a number\"\n```\n\n\n**In TypeScript, variables are “born” with their types.** Although there are ways of making them more specific in certain branches of code, there’s no (safe) way of changing age’s type from number to string.\n\n<br>\n\nLet’s try the same thing with const:\n\n```\nconst age = 6\n```\n\n\nNotice that the type of this variable is not **number**, it’s **6**. **TS is able to make a more specific assumption here**, because:\n\n+ const variable declarations cannot be reassigned\n+ the initial value assigned to age is a number, which is an **immutable value type**\n\nTherefore, **age** will always be **6** in this program.\n\n\n## Literal Types\nThe type **6** is called a **literal type**. If our let declaration is a variable that can hold any number, the const declaration is one that can hold only 6 — a specific number.\n\n\n## Implicit any and type annotations\n\nSometimes, we need to declare a variable before it gets initialized, like **endTime** below:\n\n```js\n// between 500 and 1000\nconst RANDOM_WAIT_TIME =\n  Math.round(Math.random() * 500) + 500\n \nlet startTime = new Date()\nlet endTime\n      \nlet endTime: any\n \nsetTimeout(() => {\n  endTime = 0\n  endTime = new Date()\n}, RANDOM_WAIT_TIME)\n\n```\n\n\n\n**endTime** is “born” without a type, so it ends up being an implicit **any**.\n\nTypeScript doesn’t have enough information around the declaration site to infer what endTime should be, so it gets the **most flexible type: any**.\n\nThink of any as “the normal way JS variables work”, in that you could assign endTime to a number, then later a function, then a string.\n\nIf we wanted more safety here, we could add a **type annotation**:\n```js\n// between 500 and 1000\nconst RANDOM_WAIT_TIME =\n  Math.round(Math.random() * 500) + 500\n \nlet startTime = new Date()\nlet endTime: Date\n      \nlet endTime: Date\n \nsetTimeout(() => {\n  endTime = 0\nType 'number' is not assignable to type 'Date'.\n  endTime = new Date()\n}, RANDOM_WAIT_TIME)\n```\n\nNow, TypeScript will correctly alert us when we try to flip flop between the number **0** and a **Date**.\n\n\n\n## Function arguments and return values\nThe **: foo** syntax we’ve just seen for variable type annotations can also be used to describe function arguments and return values. In this example it’s not clear, even from the implementation of the function, whether **add** should accept numbers or strings.\n\n```js\nfunction add(a, b) {\n  return a + b // strings? numbers? a mix?\n}\n```\n\n\nHere’s what your in-editor tooltip would look like if you were using this function:\n\n```js\nconst result = add(3, \"4\")\n//function add(a: any, b: any): any\nresult\n```\n\nWithout type annotations, “anything goes” for the arguments passed into **add**. Why is this a problem?\n\n```js\nconst result = add(3, \"4\")\nconst p = new Promise(result)\n```\n\n\nIf you’ve ever created a Promise using the promise constructor, you may see that we are using a string where we should use a two-argument function. This is the kind of thing we’d hope that TypeScript could catch for us.\n\n<br>\n\nWithout type annotations, “anything goes” for the arguments passed into add. Why is this a problem?\n\nLet’s add some type annotations to our function’s arguments:\n\n\n```js\nfunction add(a: number, b: number) {\n  return a + b\n}\nconst result = add(3, \"4\")\n```\n\n\nGreat, now we can enforce that only values of type **number** are passed into the function, and TS can now determine the return type automatically:\n\n```js\nfunction add(a: number, b: number) {\n  return a + b\n}\nconst result = add(3, 4)\n```\n\nIf we wanted to specifically state a return type, we could do so using the :foo syntax in one more place\n```js\nfunction add(a: number, b: number): number {}\n```\n\nThis is a great way for code authors to state their intentions up-front. TypeScript will make sure that we live up to this intention, and errors will be surfaced at the location of the function declaration instead of where we use the value returned by the function.","slug":"Variables-Values","title":"Variables and Values","section":"TypeScript Language","icon":"file-code","filePath":"/home/runner/work/ts-course/ts-course/lessons/03-TypeScript-Language/A-Variables-Values.md","nextSlug":null,"prevSlug":"/ts-course/lessons/Setup/hello-typescript"}},"__N_SSG":true}